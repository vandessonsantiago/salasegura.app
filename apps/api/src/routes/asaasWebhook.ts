import { Router, Request, Response } from 'express';
import { updatePaymentStatus } from '../services/PaymentService';
import { createCalendarEvent } from '../services/google-calendar';

const router: Router = Router();

// Webhook do Asaas para atualiza√ß√£o de status de pagamento
router.post('/', async (req: Request, res: Response) => {
  try {
    console.log('üîÑ Webhook Asaas recebido:', JSON.stringify(req.body, null, 2));

    // O Asaas envia eventos de pagamento via POST
    const { event, payment } = req.body;

    // Valida√ß√£o b√°sica
    if (!payment?.id || !event) {
      console.error('‚ùå Webhook inv√°lido - faltando payment.id ou event');
      return res.status(400).json({ error: 'Dados do webhook inv√°lidos' });
    }

    console.log(`üì° Processando webhook: ${event} para pagamento ${payment.id}`);

    // Verificar se este webhook j√° foi processado (prevenir duplicatas)
    const { supabaseAdmin } = require('../lib/supabase');
    const { data: existingLogs } = await supabaseAdmin
      .from('webhook_logs')
      .select('id, status, created_at')
      .eq('payment_id', payment.id)
      .eq('event_type', event)
      .order('created_at', { ascending: false })
      .limit(5);

    // Se j√° existe um log processado para este evento, ignorar
    const alreadyProcessed = existingLogs?.some((log: any) => log.status === 'processed');
    if (alreadyProcessed) {
      console.log(`‚ö†Ô∏è Webhook j√° processado anteriormente: ${event} para ${payment.id}`);
      return res.status(200).json({
        success: true,
        message: 'Webhook j√° processado anteriormente'
      });
    }

    // Se h√° m√∫ltiplos logs 'received' recentes (√∫ltimos 5 minutos), pode ser duplica√ß√£o
    const recentReceivedLogs = existingLogs?.filter((log: any) => {
      const logTime = new Date(log.created_at);
      const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);
      return log.status === 'received' && logTime > fiveMinutesAgo;
    }) || [];

    if (recentReceivedLogs.length > 0) {
      console.log(`‚ö†Ô∏è Webhook possivelmente duplicado detectado: ${event} para ${payment.id} (${recentReceivedLogs.length} logs recentes)`);
      // Ainda processa, mas loga o poss√≠vel duplicado
    }

    // S√≥ processar eventos relevantes de pagamento
    const relevantEvents = ['PAYMENT_RECEIVED', 'PAYMENT_CONFIRMED', 'PAYMENT_OVERDUE', 'PAYMENT_DELETED', 'PAYMENT_PENDING', 'PAYMENT_CREATED'];
    if (!relevantEvents.includes(event)) {
      console.log(`‚ÑπÔ∏è Evento n√£o relevante ignorado: ${event}`);
      return res.status(200).json({
        success: true,
        message: 'Evento n√£o relevante, ignorado'
      });
    }

    // Log do webhook no banco para auditoria
    // Primeiro, encontrar o registro de pagamento pelo asaas_id
    const { data: webhookPaymentRecord } = await supabaseAdmin
      .from('payments')
      .select('id')
      .eq('asaas_id', payment.id)
      .single();

    await supabaseAdmin
      .from('webhook_logs')
      .insert({
        event_type: event,
        payment_id: webhookPaymentRecord?.id || null, // Usar o UUID interno, n√£o o asaas_id
        payload: req.body,
        status: 'received'
      })
      .then(({ error }: { error: any }) => {
        if (error) console.error('Erro ao salvar log do webhook:', error);
      });

    // Atualiza status do pagamento no Supabase
    try {
      await updatePaymentStatus(payment.id, payment.status);
      console.log(`‚úÖ Status do pagamento ${payment.id} atualizado para ${payment.status}`);
    } catch (error) {
      console.error(`‚ùå Erro ao atualizar status do pagamento ${payment.id}:`, error);
      return res.status(500).json({ error: 'Erro ao atualizar status do pagamento' });
    }

    // Buscar registro de pagamento para obter agendamento_id
    const { data: paymentRecord, error: paymentError } = await supabaseAdmin
      .from('payments')
      .select('agendamento_id, user_id')
      .eq('asaas_id', payment.id)
      .single();

    if (paymentError) {
      console.error('‚ùå Erro ao buscar pagamento para atualizar agendamento:', paymentError);
      // Mesmo com erro, continua o processamento
    }

    // Se n√£o encontrou na tabela payments, tentar buscar pelo payment_id no agendamento
    let agendamentoId = paymentRecord?.agendamento_id;

    if (!agendamentoId) {
      console.log(`üîç Procurando agendamento diretamente pelo payment_id: ${payment.id}`);
      const { data: agendamento, error: agendamentoError } = await supabaseAdmin
        .from('agendamentos')
        .select('id, user_id')
        .eq('payment_id', payment.id)
        .single();

      if (agendamentoError) {
        console.error('‚ùå Erro ao buscar agendamento pelo payment_id:', agendamentoError);
      } else if (agendamento) {
        agendamentoId = agendamento.id;
        console.log(`‚úÖ Agendamento encontrado: ${agendamentoId}`);
      }
    }

    // Se houver agendamento_id, atualizar status do agendamento/caso
    if (agendamentoId) {
      // Primeiro determinar se √© agendamento ou div√≥rcio
      let serviceType = 'agendamento';
      let tableName = 'agendamentos';

      // Verificar se existe na tabela divorce_cases
      const { data: divorceCheck } = await supabaseAdmin
        .from('divorce_cases')
        .select('id')
        .eq('id', agendamentoId)
        .single();

      if (divorceCheck) {
        serviceType = 'divorcio';
        tableName = 'divorce_cases';
        console.log(`üèõÔ∏è Webhook detectou caso de div√≥rcio: ${agendamentoId}`);
      } else {
        console.log(`üìÖ Webhook detectou agendamento: ${agendamentoId}`);
      }

      // Reconhecer todos os status v√°lidos do Asaas que indicam pagamento conclu√≠do
      const completedStatuses = ['RECEIVED', 'CONFIRMED', 'PAID', 'COMPLETED', 'APPROVED'];
      const recordStatus = completedStatuses.includes(payment.status)
        ? 'CONFIRMED'
        : payment.status;

      const { error: updateError } = await supabaseAdmin
        .from(tableName)
        .update({
          status: recordStatus,
          updated_at: new Date().toISOString()
        })
        .eq('id', agendamentoId);

      if (updateError) {
        console.error(`‚ùå Erro ao atualizar ${serviceType}:`, updateError);
      } else {
        console.log(`‚úÖ ${serviceType} ${agendamentoId} atualizado para ${recordStatus}`);

        // Se o agendamento/caso foi confirmado, criar evento no Google Calendar
        if (recordStatus === 'CONFIRMED') {
          try {
            // Primeiro tentar buscar na tabela agendamentos
            let agendamento = null;
            serviceType = 'agendamento';

            const { data: agendamentoData, error: agendamentoFetchError } = await supabaseAdmin
              .from('agendamentos')
              .select('*')
              .eq('id', agendamentoId)
              .single();

            if (agendamentoData) {
              agendamento = agendamentoData;
              serviceType = 'agendamento';
            } else {
              // Se n√£o encontrou em agendamentos, tentar buscar em divorce_cases
              console.log(`üîÑ Agendamento n√£o encontrado, tentando buscar em divorce_cases: ${agendamentoId}`);
              const { data: divorceData, error: divorceFetchError } = await supabaseAdmin
                .from('divorce_cases')
                .select('*')
                .eq('id', agendamentoId)
                .single();

              if (divorceData) {
                agendamento = divorceData;
                serviceType = 'divorcio';
                console.log(`‚úÖ Caso de div√≥rcio encontrado: ${agendamentoId}`);
              } else {
                console.error('‚ùå Erro ao buscar dados do agendamento/div√≥rcio para criar evento:', agendamentoFetchError || divorceFetchError);
              }
            }

            if (agendamento) {
              console.log(`üìÖ Criando evento no Google Calendar para ${serviceType} ${paymentRecord.agendamento_id}`);

              // Adaptar campos baseado no tipo de servi√ßo
              const eventData = {
                date: serviceType === 'agendamento' ? agendamento.data : null, // Div√≥rcios podem n√£o ter data espec√≠fica
                time: serviceType === 'agendamento' ? agendamento.horario : '09:00', // Hor√°rio padr√£o para div√≥rcios
                summary: serviceType === 'agendamento'
                  ? `Consulta - ${agendamento.cliente_nome}`
                  : `Div√≥rcio Express - ${agendamento.cliente_nome}`,
                description: serviceType === 'agendamento'
                  ? (agendamento.descricao || 'Consulta de alinhamento inicial')
                  : (agendamento.descricao || 'Processo de div√≥rcio express'),
                attendees: [agendamento.cliente_email],
                durationMinutes: serviceType === 'agendamento' ? 45 : 60 // Dura√ß√£o diferente para div√≥rcios
              };

              // S√≥ criar evento se tiver data (para agendamentos) ou para div√≥rcios sem data espec√≠fica
              if (eventData.date || serviceType === 'divorcio') {
                const { eventId, meetLink } = await createCalendarEvent(eventData);

                console.log(`üîç Debug Google Calendar:`, {
                  eventId,
                  meetLink,
                  hasEventId: !!eventId,
                  hasMeetLink: !!meetLink,
                  meetLinkLength: meetLink?.length,
                  isEmptyString: meetLink === "",
                  agendamentoId: agendamentoId,
                  serviceType: serviceType
                });

                // Atualizar o registro com dados do Google Calendar
                if (eventId || meetLink) {
                  const updateData: any = {
                    calendar_event_id: eventId,
                    updated_at: new Date().toISOString()
                  };

                  if (meetLink) {
                    updateData.google_meet_link = meetLink;
                  }

                  const tableToUpdate = serviceType === 'agendamento' ? 'agendamentos' : 'divorce_cases';
                  const { error: updateCalendarError } = await supabaseAdmin
                    .from(tableToUpdate)
                    .update(updateData)
                    .eq('id', agendamentoId);

                  if (updateCalendarError) {
                    console.error(`‚ùå Erro ao atualizar ${tableToUpdate} com dados do Google Calendar:`, updateCalendarError);
                  } else {
                    console.log(`‚úÖ ${tableToUpdate} atualizado com dados do Google Calendar`);
                  }
                }
              } else {
                console.log(`‚ö†Ô∏è Pulando cria√ß√£o de evento: ${serviceType} sem data definida`);
              }
            }
          } catch (calendarError) {
            console.error('‚ùå Erro ao criar evento no Google Calendar:', calendarError);
          }
        }
      }
    }

    // Marcar log como processado
    await supabaseAdmin
      .from('webhook_logs')
      .update({
        status: 'processed',
        processed_at: new Date().toISOString()
      })
      .eq('payment_id', payment.id)
      .eq('status', 'received');

    // Retorna sucesso para o Asaas
    console.log(`‚úÖ Webhook ${event} processado com sucesso para pagamento ${payment.id}`);
    res.status(200).json({
      success: true,
      message: 'Webhook processado com sucesso'
    });

  } catch (error) {
    console.error('‚ùå Erro geral no webhook Asaas:', error);

    // Sempre retornar uma resposta para evitar looping
    try {
      // Log do erro
      const { supabaseAdmin } = require('../lib/supabase');
      await supabaseAdmin
        .from('webhook_logs')
        .insert({
          event_type: req.body?.event || 'unknown',
          payment_id: req.body?.payment?.id || 'unknown',
          payload: req.body || {},
          status: 'error'
        })
        .then(({ error: logError }: { error: any }) => {
          if (logError) console.error('Erro ao salvar log de erro:', logError);
        });
    } catch (logError) {
      console.error('Erro ao salvar log de erro do webhook:', logError);
    }

    // Sempre retornar 200 para evitar que o Asaas fique tentando reenviar
    res.status(200).json({
      success: false,
      message: 'Erro ao processar webhook, mas reconhecido',
      error: error instanceof Error ? error.message : 'Erro interno'
    });
  }
});

export default router;
